{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Compose Form","text":"<p>A lightweight and customisable Form builder DSL for Compose Multiplatform</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Cross-platform support</li> <li>Build compose forms in a quick and reusable way</li> <li>Built in validation on a field and form wide level</li> <li>Access current form value statefully and at the ViewModel level</li> <li>Observe value changes</li> <li>Out of the box input fields</li> <li>Implement custom fields to match your design</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#setup","title":"Setup","text":""},{"location":"#android","title":"Android","text":"<pre><code>dependencies{\n    ...\n    implementation(\"io.github.idscodelabs:compose-form:$version\")\n}\n</code></pre>"},{"location":"#multiplatform","title":"Multiplatform","text":"<pre><code>commonMain.dependencies{\n    ...\n    implementation(\"io.github.idscodelabs:compose-form:$version\")\n}\n</code></pre>"},{"location":"#version-catalog","title":"Version catalog","text":""},{"location":"#toml","title":"TOML","text":"<pre><code>[versions]\ncompose-form = \"&lt;version&gt;\"\n\n[libraries]\ncompose-form = { module = \"io.github.idscodelabs:compose-form\", version.ref = \"compose-form\" }\n</code></pre>"},{"location":"#buildgradlekts","title":"build.gradle.kts","text":"<pre><code>commonMain.dependencies{\n    ...\n    implementation(libs.compose.form)\n}\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<pre><code>\n// Define your model\ndata class FormTextFieldExampleModel(\n    var value: String? = null,\n)\n\n...\n\n// Create the form\nForm(emptyModel = ::FormTextFieldExampleModel) {\n\n    // Add fields\n    FormTextField(\n        modelProperty = FormTextFieldExampleModel::value,\n        validator = NotEmptyValidator(), // Add validation\n        updateModel = { value = it },\n        hint = \"Value\"\n    )\n\n    // Submit the form\n    Button(onClick = submitFunction {\n        // Do something with the result\n    }) {\n        Text(\"Submit\")\n    }\n}\n\n</code></pre>"},{"location":"#full-documentation","title":"Full Documentation","text":""},{"location":"fields/Common/","title":"Form Fields","text":""},{"location":"fields/Common/#common-properties","title":"Common properties","text":"<p>All form fields have the following parameters</p>"},{"location":"fields/Common/#modelproperty","title":"<code>modelProperty</code>","text":"<p>This is the parameter in the form's model which this property relates to. This is used behind the scenes as a unique key for the form field to be stored against, so it is generally not advised to have 2 or more fields referring to the same property</p> <p>The easiest way to provide this value is obtaining a reference to the property with <code>::</code>, for instance:</p> <pre><code>SomeFormField(\n    modelProperty = SomeModel::someValue\n)\n</code></pre>"},{"location":"fields/Common/#updatemodel","title":"<code>updateModel</code>","text":"<p>This is the function which should be used to set the  value of the property on the Model. The incoming receiver  is the Model which is to be updated, and the value passed to the function is the value which needs to be set.</p> <p>In most use cases, the following should suffice:</p> <pre><code>SomeFormField(\n    updateModel = { someValue = it}\n)\n</code></pre>"},{"location":"fields/Common/#initialvalue","title":"<code>initialValue</code>","text":"<p>This is the initial value the form field should take.</p> <p>If this changes during the lifecycle of the form field, the value will be overwritten with the new initial value. For this reason, any non-primitives should be data classes or override the <code>equals</code> method explicitly to avoid the value being overwritten when the reference to the  object changes.</p>"},{"location":"fields/Common/#validator","title":"<code>validator</code>","text":"<p>To validate form fields, this value can be passed. </p> <p>The value is a single validator, but applying multiple validators can be achieved by using the <code>+</code> operator, or the <code>and</code> infix function. This is to avoid having complex nested lists of validators.</p> <p>For more information, see Form Validators</p>"},{"location":"fields/Common/#enabled","title":"<code>enabled</code>","text":"<p>This determines if the field is enabled or not, and can be derived from other state properties. For example, in a screen with a loading state, the following might be required</p> <pre><code>    val uiState by viewModel.uiState.collectAsState()\n\n    SomeFormField(\n        enabled = !uiState.loading\n    )\n</code></pre> <p>Note that the enabled value will stop values being set on the field, as well as being provided to the implementation to allow disabling of UI components</p>"},{"location":"fields/Common/#ui","title":"UI","text":""},{"location":"fields/Common/#default","title":"Default","text":"<p>To use the default UI, each of the Form Field functions has an overload which also contains all the properties of the default implementation of that form field. This is stored in the <code>default</code> package along with the default UI For instance with a text field</p> <pre><code>c.i.c.f.f.core.text.FormTextField(\n    modelProperty = FormTextFieldExampleModel::value,\n    validator = NotEmptyValidator(),\n    updateModel = { value = it },\n) {\n    DefaultTextEntry(hint = \"Value\")\n}\n</code></pre> <p>is the same as</p> <pre><code>c.i.c.f.f.default.text.FormTextField(\n    modelProperty = FormTextFieldExampleModel::value,\n    validator = NotEmptyValidator(),\n    updateModel = { value = it },\n    hint = \"Value\"\n)\n</code></pre> <p>(Note package names abbreviated for conciseness)</p>"},{"location":"fields/Common/#custom","title":"Custom","text":"<p>Custom UI can be implemented to suit the needs of your project.  For more info see Custom UI</p>"},{"location":"fields/CustomUI/","title":"Custom UI","text":"<p>Custom UI can be implemented by leveraging the <code>implementation</code> parameter of the Form Fields. This allows the following:</p>"},{"location":"fields/CustomUI/#obtaining-field-specific-data-in-ui","title":"Obtaining field specific data in UI","text":"<p>For example a list of options in a dropdown</p> <pre><code>FormDropdownField(\n    ...\n    options = &lt;options&gt;,\n) {\n    // Use options here directly from the DropdownFormBox\n    options.forEach{\n        Text(it.label)\n    }\n}\n</code></pre> <p>This allows you to write module code with a suite of your own UI components, for example using the function signature</p> <pre><code>fun &lt;Item : ListDisplayable&gt; DropdownFormBox&lt;*, Item&gt;.MyBrandedDropdownEntry(hint: Any?){\n    // Something using options directly\n}\n</code></pre> <p>without having to pass values down the Composable hierarchy</p>"},{"location":"fields/CustomUI/#working-with-value-direct-from-the-formbox","title":"Working with value direct from the FormBox","text":"<p>The <code>FormBox</code> provides methods to find the current value.</p> <p>For example a custom text field could look like:</p> <pre><code>fun FormBox&lt;*, TextFieldValue&gt;.MyBrandedTextEntry(hint: Any?){\n    BasicTextField(\n        value = value,\n        onValueChange = ::setValue,\n        disabled = !enabled,\n        ...Custom Styling...\n    )\n}\n</code></pre> <p>For convenience, the field value can also be - Collected directly using <code>collectValueAsState()</code> - Observed in composables using <code>FieldValueChangeEffect()</code> which works similar to <code>LaunchedEffect</code> - Observed in ViewModels or other asynchronous code using <code>FormBox.onFieldValueChanged()</code> - Obtained one off in synchronous non-compose code using <code>valueSnapshot</code></p>"},{"location":"fields/CustomUI/#handling-validation-errors","title":"Handling validation errors","text":"<p>The <code>FormBox</code> also provides an observable error.</p> <p>This can be obtained either by  - Calling <code>error</code> directly, which will provide a <code>String</code> error obtained using <code>asDisplayString()</code> - Collecting the value in the UI using <code>collectErrorAsState</code> which will provide the original <code>Any</code> returned as an error from the <code>Validator</code></p> <p>Note that the error may be null if the field is not currently in error state. The field can be validated at any time by calling the <code>validate</code> function, which will automatically set the error. The error will also be cleared whenever the value changes</p>"},{"location":"fields/CustomUI/#checking-if-the-field-is-enabled","title":"Checking if the field is enabled","text":"<p>If your application needs different styles for fields which are disabled, this can be obtained using the <code>collectEnabledAsState()</code> function or <code>enabled</code> value</p>"},{"location":"fields/CustomUI/#form-field-focus","title":"Form field focus","text":"<p>There are many scenarios where a field may be required to  be brought into focus during use of the application. For example, it may be required that in a scrollable form, the box with an error  is brought into focus on submission (see Submission Failure)</p> <p>For this application, the modifier <code>primaryFocusable</code> is provided. This should be  added to the element of your field you wish to gain focus when that FormBox requests focus. Please note in future releases the focus requester may also be used internally, so it is  important to ensure it is implemented on custom UI implementations.</p>"},{"location":"fields/TextField/","title":"Text Field","text":"<p>The text field is a key component of any form, allowing the user to input free text</p>"},{"location":"fields/TextField/#default-usage","title":"Default usage","text":"<p>Along with common fields the default text field includes multiple styling options:</p> Field Type Default Description Notes hint Any? <code>null</code> The hint field is displayed continuously no matter the value of the form field. It should give the user a prompt as to what to enter Will be converted to String using <code>asDisplayString</code> modifier Modifier <code>Modifier.fillMaxWidth()</code> Modifier to apply to the text field. placeholder Any? <code>null</code> Value to display in the field if no value is populated. Will be converted to String using <code>asDisplayString</code> leadingIcon (@Composable ()-&gt;Unit)? <code>null</code> Icon to display at the start of the field. trailingIcon (@Composable ()-&gt;Unit)? <code>null</code> Icon to display at the end of the form field. isLast Boolean <code>false</code> If this text field is the last field in the form in the UI. When this is passed as false, an IME action on the keyboard will allow advance to the next text based field, otherwise a done IME action will be displayed. keyboardOptions KeyboardOptions? <code>null</code> Use this to modify the behaviour of the keyboard used when entering text into this field. prefix Any <code>\"\"</code> A static prefix to show in the text field. This will not be included in the value. Will be converted to String using <code>asDisplayString</code> readOnly Boolean <code>false</code> If the field should be disabled style FormFieldStyle <code>LocalFormFieldStyle.current</code> Allows styling of the text box to override the default onValueChange (TextFieldValue)-&gt;Unit <code>{}</code> Gives the option to observe the value of only this text field changing, for cases where this field is a part of another field."},{"location":"validators/Validators/","title":"Form Validators","text":""}]}